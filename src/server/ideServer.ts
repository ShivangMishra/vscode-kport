import { createHash, Hash } from 'crypto';
import * as fs from 'fs';
import * as http from 'http';
import * as https from 'https';
import * as os from 'os';
import * as path from 'path';
import { Readable } from 'stream';
import { commands, ExtensionContext, extensions, ProgressLocation, ProgressOptions, window, WorkspaceConfiguration } from "vscode";


import glob = require('glob');
import { resolve } from 'path';

const HTTPS_PATTERN = /^https:\/\//;
export const ABORTED_ERROR: Error = new Error('Kport IDE Server download cancelled by user');

export async function downloadBinary(): Promise<string> {
  const downloadPromise: Promise<string> = new Promise((resolve, reject) => {
    let webClient: http.ClientRequest;
    const handleResponse = (response: http.IncomingMessage) => {
      const statusCode = response.statusCode;
      if (statusCode === 302 || statusCode === 303) {
        if(response.headers.location) {
        webClient = httpHttpsGet(response.headers.location, handleResponse)
          .on('error', (e) => {
            reject(`Server binary download failed: ${e.message}`);
          });
        }
      } else if (statusCode === 200) {
        showProgressForDownload(response, webClient);
        const serverBinaryUrl = getServerBinaryDownloadUrl();
          // Not a ZIP, assume its a binary
          acceptBinaryDownloadResponse(response).then(resolve, reject);
      } else if (statusCode === 407) {
        const DOCUMENTATION = "Open Proxy Configuration Documentation";
        window.showErrorMessage(
          'The language server couldn\'t be downloaded, because you have not configured VS Code to use your proxy for VS Code extensions. '
          + 'For documentation on configuring the proxy, click the button below.',
          DOCUMENTATION);
        reject(`Server binary download failed: status code ${statusCode}`);
      } else {
        reject(`Server binary download failed: status code ${statusCode}`);
      }
    }
    webClient = httpHttpsGet(`${getServerBinaryDownloadUrl()}`, handleResponse)
      .on('error', (e) => {
        reject(`Server binary download failed: ${e.message}`);
      });
  });
  return downloadPromise;
}


/**
 * Writes the contents of the response to a file, marks it as executable, and returns the path to the file
 *
 * @param response The response to write to file
 * @returns the path to the file
 */
 async function acceptBinaryDownloadResponse(response: http.IncomingMessage): Promise<string> {
  return new Promise((resolve, reject) => {
    const serverBinaryPath: string = path.resolve(__dirname, '../server', getServerBinaryNameWithoutExtension() + getServerBinaryExtension());
    const serverBinaryFileStream = fs.createWriteStream(serverBinaryPath);
    let capturedError:any = null;
    serverBinaryFileStream.on('finish', () => {
      serverBinaryFileStream.close();
    });
    serverBinaryFileStream.on('close', () => {
      if (capturedError) {
        fs.unlinkSync(serverBinaryPath);
        reject(capturedError);
        return;
      }
      fs.chmodSync(serverBinaryPath, "766");
      resolve(serverBinaryPath);
    });
    response.on('aborted', () => {
      capturedError = ABORTED_ERROR;
      serverBinaryFileStream.close();
    });
    response.pipe(serverBinaryFileStream);
  });
}

/**
 * Performs https.get if the url begins with "https://", and performs http.get otherwise
 *
 * @param url The url get
 * @param callback The callback function to handle the URL request
 * @return the client request generated by https.get or http.get
 */
 function httpHttpsGet(url: string, callback: (response: http.IncomingMessage) => void): http.ClientRequest {
  if (HTTPS_PATTERN.test(url)) {
    return https.get(url, callback);
  }
  return http.get(url, callback);
}


/**
 * Show a progress notification for the given get response
 *
 * Inspired by
 * https://stackoverflow.com/questions/18323152/get-download-progress-in-node-js-with-request
 *
 * @param response the http GET response
 */
 function showProgressForDownload(response: http.IncomingMessage, httpClient: http.ClientRequest) {
  const progressOptions: ProgressOptions = {
    location: ProgressLocation.Notification,
    cancellable: true,
    title: "Downloading the Kport IDE Server..."
  };
  window.withProgress(
    progressOptions,
    (progress, cancelToken) => {
      let size: number = 0;
      if(response.headers['content-length']){
        size = parseInt(response.headers['content-length']);
      }
      let downloaded = 0;
      let previousReportedDownloadedPercent = 0;
      response.on("data", (chunk) => {
        downloaded += chunk.length;
        const incrementAmt = ((100.0 * downloaded / size) - previousReportedDownloadedPercent);
        previousReportedDownloadedPercent += incrementAmt;
        progress.report({
          increment: incrementAmt
        });
      });
      const downloadFinish: Promise<void> = new Promise((resolve, _reject) => {
        response.on("close", () => {
          resolve();
        });
      });
      cancelToken.onCancellationRequested((_e: any) => {
        httpClient.abort();
      })
      return downloadFinish;
    });
}


/**
 * Returns the URL of the server where the binary version of LemMinX should be downloaded from
 *
 * @return the URL of the server where the binary version of LemMinX should be downloaded from
 */
function getServerBinaryDownloadUrl(): string {
  return "https://github.com/jkubeio/kport/releases/download/1.0.0/"
    + getServerBinaryNameWithoutExtension()
    + getServerBinaryExtension();
}
/**
 * Returns the name of the server binary file for the current OS and architecture
 *
 * @return the name of the server binary file for the current OS and architecture
 */
 function getServerBinaryNameWithoutExtension(): string {
    switch (os.platform()) {
      case 'darwin':
        return 'kport-ide-server-macOS';
      case 'win32':
        return 'kport-ide-server-Windows';
      case 'linux':
        return 'kport-ide-server-Linux';
      default:
        return `kport-ide-server-${os.platform}`;
    }
  }
  
  /**
   * Returns the extension of the binary server for the current OS
   *
   * @return the extension of the binary server for the current OS
   */
  function getServerBinaryExtension(): string {
    switch (os.platform()) {
      case 'win32':
        return '.exe';
      default:
        return '';
    }
  }